use std::net::SocketAddr;

use clap::ArgMatches;
use log::{info, debug};
use futures::{future::{self, Ready}, prelude::*};
use tarpc::{server::{self, Handler, Channel}};
use tokio_serde::formats::Json;

use crate::db::DbBroker;
use crate::xpc::Collector;

mod collector;

#[derive(Debug)]
pub struct Master {
    listen_addr: SocketAddr,
}

impl Master {
    fn new(listen_address: &str) -> Master {
        debug!("Initializing new master");
        let master = Master {
            listen_addr: listen_address.parse().expect("Invalid listen address provided"),
        };
        master
    }

    #[tokio::main]
    async fn main_loop(&self) -> Result<(), Box<dyn std::error::Error>> {
        let db_broker = DbBroker::new();
        // Initialize all grpc services with database handle
        let collector_service = collector::CollectorService::new(db_broker);

        // Tarpc start
        debug!("Starting master event loop on {}", self.listen_addr);
        tarpc::serde_transport::tcp::listen(&self.listen_addr, Json::default)
            .await.expect("Unable to listen on port")
            // Ignore accept errors.
            .filter_map(|r| future::ready(r.ok()))
            .map(server::BaseChannel::with_defaults)
            // Limit channels to 1 per IP.
            .max_channels_per_key(1, |t| t.as_ref().peer_addr().unwrap().ip())
            // serve is generated by the service attribute. It takes as input any type implementing
            // the generated World trait.
            .map(|channel| {
                channel.respond_with(collector_service.clone().serve()).execute()
            })
            // Max 10 channels.
            .buffer_unordered(10)
            .for_each(|_| async {})
            .await;

        Ok(())
    }
}

pub fn main(arg_matches: &ArgMatches) {
    debug!("Master main launched!");

    match arg_matches.subcommand() {
        ("start", Some(sub_matches)) => {
            info!("Starting master agent");
            let master = Master::new(sub_matches.value_of("listen_addr").unwrap());

            if let Err(e) = master.main_loop() {
                panic!("{}", e);
            }
        },
        _ => {}
    }
}
